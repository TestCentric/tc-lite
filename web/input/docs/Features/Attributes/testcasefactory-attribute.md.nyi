Title: TestCaseFactoryAttribute
Description: Identifies a test method together with a test case factory to provide arguments. Use of a factory provides the greatest level of control in generating arguments dynamically.
---

**TestCaseFactoryAttribute** is used on a parameterized test method to identify the factory Type,
which will provide the required arguments. The attribute additionally identifies the method as a
test method. By use of a factory, the data is kept separate from the test itself and may be used
by multiple test methods.

# Usage

Consider a test of the divide operation, taking three arguments: the numerator, the denominator and the expected result. We can specify the test and its data using **TestCaseSourceAttribute**,
as follows:

```c#
public class MyTestClass
{
    [TestCaseSource(typeof(DivideCases))]
    public void DivideTest(int n, int d, int q)
    {
        Assert.AreEqual(q, n / d);
    }
}

class DivideCases : ITestFactory
{
    public IEnumerator<ITestCaseData> GetEnumerator()
    {
        yield return new TestCaseData( 12, 3, 4 );
        yield return new TestCaseData( 12, 2, 6 );
        yield return new TestCaseData( 12, 4, 3 );
    }
}
```

The Type argument in this form represents the class that provides test cases.
It must have a default constructor and implement `ITestCaseData`. The enumerator
should return test case data compatible with the signature of the test on which
the attribute appears.

See the **Test Case Construction** section below for details.

Note that it is not possible to pass parameters to the source, even if the source is a method.

# Named Parameters

**TestCaseFactoryAttribute** supports one named parameter:

* **Category** is used to assign one or more categories to every test case returned from this source.

# Notes

1. It is recommended that the SourceType not be the same as the test fixture class. It may be a nested class, however, and probably should be if the data is only used within that fixture.
2. A generic `IEnumerable` and `IEnumerator` may be used but NUnit will actually deal with the underlying `IEnumerator` in the current release.
3. The GetEnumerator method may use yield statements or simply return the enumerator for an array or other collection held by the class.

## Order of Execution

Individual test cases are executed in the order in which NUnit discovers them. This order does **not**
follow the lexical order of the attributes and will often vary between different
compilers or different versions of the CLR.

As a result, when **TestCaseSourceAttribute** appears multiple times on a
method or when other data-providing attributes are used in combination with
**TestCaseSourceAttribute**, the order of the test cases is undefined.

However, when a single **TestCaseSourceAttribute** is used by itself,
the order of the tests follows exactly the order in which the test cases
are returned from the source.

## Object Construction

NUnit locates the test cases at the time the tests are loaded. It creates
instances of each class used with the third form of the attribute and builds a list of
tests to be executed. Each data source class is only created once at this
time and is destroyed after all tests are loaded. By design, no communication is
possible between the load and execution phases except through the tests that
are created.
